= EM-HTTP-Client

EventMachine based HTTP Request interface. Supports streaming response processing, uses Ragel HTTP parser.
- Simple interface for single & parallel requests via deferred callbacks
- Automatic gzip & deflate decoding
- Basic-Auth & OAuth support
- Custom timeouts
- Proxy support (with SSL Tunneling)
- Auto-follow 3xx redirects with max depth
- Bi-directional communication with web-socket services

Screencast / Demo of using EM-HTTP-Request:
- http://everburning.com/news/eventmachine-screencast-em-http-request/

== Getting started

  # install & configure gemcutter repos
  gem update --system
  gem install gemcutter
  gem tumble

  gem install em-http-request

  irb:0> require 'em-http'

== Simple client example

  EventMachine.run {
    http = EventMachine::HttpRequest.new('http://127.0.0.1/').get :query => {'keyname' => 'value'}, :timeout => 10

    http.callback {
      p http.response_header.status
      p http.response_header
      p http.response

      EventMachine.stop
    }
  }

== Multi request example
Fire and wait for multiple requess to complete via the MultiRequest interface.

  EventMachine.run {
    multi = EventMachine::MultiRequest.new

    # add multiple requests to the multi-handler
    multi.add(EventMachine::HttpRequest.new('http://www.google.com/').get)
    multi.add(EventMachine::HttpRequest.new('http://www.yahoo.com/').get)

    multi.callback  {
      p multi.responses[:succeeded]
      p multi.responses[:failed]

      EventMachine.stop
    }
  }

== Basic-Auth example
Full basic author support. For OAuth, check examples/oauth-tweet.rb file.

  EventMachine.run {
    http = EventMachine::HttpRequest.new('http://www.website.com/').get :head => {'authorization' => ['user', 'pass']}

    http.errback { failed }
    http.callback {
      p http.response_header
      EventMachine.stop
    }
  }


== POST example
  EventMachine.run {
    http1 = EventMachine::HttpRequest.new('http://www.website.com/').post :body => {"key1" => 1, "key2" => [2,3]}
    http2 = EventMachine::HttpRequest.new('http://www.website.com/').post :body => "some data"

    # ...
  }

== Streaming body processing
Allows you to consume an HTTP stream of content in real-time. Each time a new piece of conent is pushed
to the client, it is passed to the stream callback for you to operate on.

  EventMachine.run {
    http = EventMachine::HttpRequest.new('http://www.website.com/').get
    http.stream { |chunk| print chunk }
  }

== Streaming file from disk
Allows you to efficiently stream a (large) file from disk via EventMachine's FileStream interface.

  EventMachine.run {
    http = EventMachine::HttpRequest.new('http://www.website.com/').post :file => 'largefile.txt'
    http.callback { |chunk| puts "Upload finished!" }
  }

== Proxy example
Full transparent proxy support with support for SSL tunneling.

  EventMachine.run {
    http = EventMachine::HttpRequest.new('http://www.website.com/').get :proxy => {
      :host => 'www.myproxy.com',
      :port => 8080,
      :authorization => ['username', 'password'] # authorization is optional
  }

== Auto-follow 3xx redirects
Specify the max depth of redirects to follow, default is 0.

  EventMachine.run {
    http = EventMachine::HttpRequest.new('http://www.google.com/').get :redirects => 1
    http.callback { p http.last_effective_url }
  }


== WebSocket example
Bi-directional communication with WebSockets: simply pass in a ws:// resource and the client will
negotiate the connection upgrade for you. On successfull handshake the callback is invoked, and
any incoming messages will be passed to the stream callback. The client can also send data to the
server at will by calling the "send" method!
- http://www.igvita.com/2009/12/22/ruby-websockets-tcp-for-the-browser/

  EventMachine.run {
    http = EventMachine::HttpRequest.new("ws://yourservice.com/websocket").get :timeout => 0

    http.errback { puts "oops" }
    http.callback {
      puts "WebSocket connected!"
      http.send("Hello client")
    }

    http.stream { |msg|
      puts "Recieved: #{msg}"
      http.send "Pong: #{msg}"
    }

    http.disconnect { puts "oops, dropped connection?" }
  }

== Mocking
To do mock-style testing with EventMachine::HttpRequest, use MockHttpRequest to take over normal requests sent through HttpRequest. To enable mock requests, you can either use <tt>activate!/deactive!</tt> or +use+

  EventMachine::MockHttpRequest.use {
    # .. request code
  }
  
Or

  EventMachine::MockHttpRequest.activate!
    # .. request code
  EventMachine::MockHttpRequest.deactivate!

To add a request to be mocked, use register or register_file

  EventMachine::MockHttpRequest.use {
    EventMachine::MockHttpRequest.register("http://something.com/test", :get, <<-CONTENT)
  HTTP/1.0 200 OK
  Date: Mon, 16 Nov 2009 20:39:15 GMT
  Expires: -1
  Cache-Control: private, max-age=0
  Content-Type: text/html; charset=ISO-8859-1
  Via: 1.0 .:80 (squid)
  Connection: close

  This is my awesome content
    CONTENT
  }

Or if your content is in a file, you can use the following:

  EventMachine::MockHttpRequest.use {
    EventMachine::MockHttpRequest.register_file("http://something.com/test", :get, "path_to_mock")
  }

If you need to use headers as well, you can define them the following way:

  EventMachine::MockHttpRequest.use {
    EventMachine::MockHttpRequest.register("http://something.com/test", :get, {'Authorization' => 'Basic user:pass'}, <<-CONTENT)
  HTTP/1.0 200 OK
  Date: Mon, 16 Nov 2009 20:39:15 GMT
  Expires: -1
  Cache-Control: private, max-age=0
  Content-Type: text/html; charset=ISO-8859-1
  Via: 1.0 .:80 (squid)
  Connection: close

  This is my awesome content
    CONTENT
  }

Or, with a file:

  EventMachine::MockHttpRequest.use {
    EventMachine::MockHttpRequest.register_file("http://something.com/test", :get, {'Authorization' => 'Basic user:pass'}, "path_to_mock")
  }

As well, mocking can be configured to pass through requests or not.

  EventMachine::MockHttpRequest.pass_through_requests = true # or false!

You can reset the registry at any point using

  EventMachine::MockHttpRequest.reset_registry!

To test if your mock was called, you can access the number of times each resource was called using

  EventMachine::HttpRequest.count('http://www.google.ca:80/', :get)

You can reset the count at any point using

  EventMachine::MockHttpRequest.reset_counts!

